import { useState, useEffect } from 'react';
import {
  Card,
  Row,
  Col,
  Button,
  Space,
  Select,
  DatePicker,
  Typography,
  Form,
  Input,
  Checkbox,
  message,
  Alert,
  Tag,
  Statistic,
  List,
  Empty,
} from 'antd';
import {
  FileTextOutlined,
  FilePdfOutlined,
  DownloadOutlined,
  PrinterOutlined,
  CheckCircleOutlined,
  BarChartOutlined,
  DatabaseOutlined,
  ExperimentOutlined,
  HistoryOutlined,
} from '@ant-design/icons';
import { AdminLayout } from '../../../components/layouts';
import { api } from '../../../services/api';
import type { Device, SensorReading, ReportType, ReportConfig, ReportHistory } from '../../../schemas';
import dayjs from 'dayjs';
import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';

const { Title, Text } = Typography;
const { RangePicker } = DatePicker;
const { TextArea } = Input;

const ManageReports = () => {
  const [devices, setDevices] = useState<Device[]>([]);
  const [selectedType, setSelectedType] = useState<ReportType>('water-quality');
  const [loading, setLoading] = useState(false);
  const [generating, setGenerating] = useState(false);
  const [reportHistory, setReportHistory] = useState<ReportHistory[]>([]);
  const [form] = Form.useForm();

  useEffect(() => {
    loadDevices();
    loadReportHistory();
  }, []);

  const loadDevices = async () => {
    setLoading(true);
    try {
      const data = await api.listDevices();
      setDevices(data);
    } catch (error) {
      message.error('Failed to load devices');
      console.error('Error loading devices:', error);
    } finally {
      setLoading(false);
    }
  };

  const loadReportHistory = () => {
    // Simulate report history (in real app, fetch from backend)
    const history: ReportHistory[] = [
      {
        id: '1',
        type: 'Water Quality Report',
        title: 'Monthly Water Quality Analysis',
        generatedAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000),
        devices: 3,
        pages: 8,
      },
      {
        id: '2',
        type: 'Device Status Report',
        title: 'Weekly Device Health Check',
        generatedAt: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
        devices: 5,
        pages: 4,
      },
    ];
    setReportHistory(history);
  };

  const generateWaterQualityReport = async (config: ReportConfig, sensorData: SensorReading[]) => {
    const doc = new jsPDF();
    let yPos = 20;

    // Add header with logo placeholder
    doc.setFillColor(0, 31, 63); // Navy blue
    doc.rect(0, 0, 210, 40, 'F');
    
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(24);
    doc.setFont('helvetica', 'bold');
    doc.text('Water Quality Report', 105, 20, { align: 'center' });
    
    doc.setFontSize(12);
    doc.setFont('helvetica', 'normal');
    doc.text(config.title, 105, 30, { align: 'center' });

    // Reset text color
    doc.setTextColor(0, 0, 0);
    yPos = 50;

    // Report Information
    doc.setFontSize(10);
    doc.setFont('helvetica', 'bold');
    doc.text('Report Information', 20, yPos);
    yPos += 7;

    doc.setFont('helvetica', 'normal');
    doc.setFontSize(9);
    doc.text(`Generated: ${dayjs().format('MMMM D, YYYY [at] h:mm A')}`, 20, yPos);
    yPos += 5;
    doc.text(`Generated By: ${config.generatedBy}`, 20, yPos);
    yPos += 5;
    
    if (config.dateRange) {
      doc.text(
        `Period: ${config.dateRange[0].format('MMM D, YYYY')} - ${config.dateRange[1].format('MMM D, YYYY')}`,
        20,
        yPos
      );
      yPos += 5;
    }
    
    doc.text(`Devices Monitored: ${config.deviceIds.length}`, 20, yPos);
    yPos += 10;

    // Summary Statistics
    if (config.includeStatistics && sensorData.length > 0) {
      // Safe division - already protected by sensorData.length > 0 check above
      const avgTurbidity = sensorData.reduce((sum, d) => sum + d.turbidity, 0) / sensorData.length;
      const avgTDS = sensorData.reduce((sum, d) => sum + d.tds, 0) / sensorData.length;
      const avgPH = sensorData.reduce((sum, d) => sum + d.ph, 0) / sensorData.length;

      const maxTurbidity = Math.max(...sensorData.map(d => d.turbidity));
      const maxTDS = Math.max(...sensorData.map(d => d.tds));
      const maxPH = Math.max(...sensorData.map(d => d.ph));
      const minPH = Math.min(...sensorData.map(d => d.ph));

      doc.setFontSize(10);
      doc.setFont('helvetica', 'bold');
      doc.text('Executive Summary', 20, yPos);
      yPos += 7;

      doc.setFontSize(9);
      doc.setFont('helvetica', 'normal');
      
      autoTable(doc, {
        startY: yPos,
        head: [['Parameter', 'Average', 'Min/Max', 'Safe Range', 'Status']],
        body: [
          [
            'Turbidity',
            `${avgTurbidity.toFixed(2)} NTU`,
            `${Math.min(...sensorData.map(d => d.turbidity)).toFixed(2)} / ${maxTurbidity.toFixed(2)}`,
            '0 - 5 NTU',
            avgTurbidity <= 5 ? 'GOOD' : 'WARNING'
          ],
          [
            'TDS',
            `${avgTDS.toFixed(2)} ppm`,
            `${Math.min(...sensorData.map(d => d.tds)).toFixed(2)} / ${maxTDS.toFixed(2)}`,
            '0 - 500 ppm',
            avgTDS <= 500 ? 'GOOD' : 'WARNING'
          ],
          [
            'pH Level',
            avgPH.toFixed(2),
            `${minPH.toFixed(2)} / ${maxPH.toFixed(2)}`,
            '6.5 - 8.5',
            (avgPH >= 6.5 && avgPH <= 8.5) ? 'GOOD' : 'WARNING'
          ],
        ],
        styles: { fontSize: 8, cellPadding: 3 },
        headStyles: { fillColor: [0, 31, 63], textColor: [255, 255, 255] },
        alternateRowStyles: { fillColor: [245, 245, 245] },
        columnStyles: {
          4: { 
            cellWidth: 25,
            fontStyle: 'bold',
          }
        },
        didParseCell: function(data: any) {
          if (data.column.index === 4) {
            const status = data.cell.raw;
            if (status === 'GOOD') {
              data.cell.styles.textColor = [82, 196, 26];
            } else {
              data.cell.styles.textColor = [250, 173, 20];
            }
          }
        },
      });

      yPos = (doc as any).lastAutoTable.finalY + 10;
    }

    // Quality Assessment
    if (sensorData.length > 0) {
      const validReadings = sensorData.filter(d => 
        d.turbidity <= 5 && d.tds <= 500 && d.ph >= 6.5 && d.ph <= 8.5
      ).length;
      // Safe division - protected by sensorData.length > 0 check above
      const qualityScore = (validReadings / sensorData.length) * 100;

      doc.setFontSize(10);
      doc.setFont('helvetica', 'bold');
      doc.text('Overall Water Quality Assessment', 20, yPos);
      yPos += 7;

      doc.setFontSize(9);
      doc.setFont('helvetica', 'normal');
      doc.text(`Total Readings Analyzed: ${sensorData.length}`, 20, yPos);
      yPos += 5;
      doc.text(`Readings Within Safe Range: ${validReadings}`, 20, yPos);
      yPos += 5;
      
      doc.setFont('helvetica', 'bold');
      doc.setFontSize(11);
      const qualityText = qualityScore >= 90 ? 'EXCELLENT' : qualityScore >= 70 ? 'GOOD' : 'NEEDS ATTENTION';
      const qualityColor: [number, number, number] = qualityScore >= 90 ? [82, 196, 26] : qualityScore >= 70 ? [250, 173, 20] : [255, 77, 79];
      doc.setTextColor(...qualityColor);
      doc.text(`Quality Score: ${qualityScore.toFixed(1)}% - ${qualityText}`, 20, yPos);
      doc.setTextColor(0, 0, 0);
      yPos += 10;
    }

    // Detailed Data Table
    if (config.includeRawData && sensorData.length > 0) {
      // Add new page if needed
      if (yPos > 250) {
        doc.addPage();
        yPos = 20;
      }

      doc.setFontSize(10);
      doc.setFont('helvetica', 'bold');
      doc.text('Detailed Sensor Readings', 20, yPos);
      yPos += 7;

      const tableData = sensorData.slice(0, 50).map(reading => [
        reading.deviceId,
        dayjs(reading.timestamp).format('MMM D, YYYY HH:mm'),
        reading.turbidity.toFixed(2),
        reading.tds.toFixed(2),
        reading.ph.toFixed(2),
        (reading.turbidity <= 5 && reading.tds <= 500 && reading.ph >= 6.5 && reading.ph <= 8.5) ? 'OK' : '⚠'
      ]);

      autoTable(doc, {
        startY: yPos,
        head: [['Device ID', 'Timestamp', 'Turbidity (NTU)', 'TDS (ppm)', 'pH', 'Status']],
        body: tableData,
        styles: { fontSize: 7, cellPadding: 2 },
        headStyles: { fillColor: [0, 31, 63], textColor: [255, 255, 255] },
        alternateRowStyles: { fillColor: [245, 245, 245] },
        columnStyles: {
          0: { cellWidth: 30 },
          1: { cellWidth: 40 },
          5: { halign: 'center', cellWidth: 15 }
        },
      });

      yPos = (doc as any).lastAutoTable.finalY + 10;
    }

    // Recommendations
    if (yPos > 250) {
      doc.addPage();
      yPos = 20;
    }

    doc.setFontSize(10);
    doc.setFont('helvetica', 'bold');
    doc.text('Recommendations', 20, yPos);
    yPos += 7;

    doc.setFontSize(9);
    doc.setFont('helvetica', 'normal');
    const recommendations = [
      '• Continue regular monitoring of all water quality parameters',
      '• Maintain turbidity levels below 5 NTU for optimal clarity',
      '• Keep TDS levels within 0-500 ppm range',
      '• Monitor pH levels to stay within 6.5-8.5 range',
      '• Investigate any sudden changes in sensor readings',
      '• Schedule routine sensor calibration monthly',
    ];

    recommendations.forEach(rec => {
      doc.text(rec, 20, yPos);
      yPos += 5;
    });

    // Notes
    if (config.notes) {
      yPos += 5;
      doc.setFont('helvetica', 'bold');
      doc.text('Additional Notes:', 20, yPos);
      yPos += 5;
      doc.setFont('helvetica', 'normal');
      const splitNotes = doc.splitTextToSize(config.notes, 170);
      doc.text(splitNotes, 20, yPos);
    }

    // Footer
    const pageCount = doc.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      doc.setFontSize(8);
      doc.setTextColor(128, 128, 128);
      doc.text(
        `Page ${i} of ${pageCount}`,
        105,
        285,
        { align: 'center' }
      );
      doc.text(
        `Generated by IoT Water Quality Monitoring System - ${dayjs().format('YYYY')}`,
        105,
        290,
        { align: 'center' }
      );
    }

    return doc;
  };

  const generateDeviceStatusReport = async (config: ReportConfig) => {
    const doc = new jsPDF();
    let yPos = 20;

    // Header
    doc.setFillColor(0, 31, 63);
    doc.rect(0, 0, 210, 40, 'F');
    
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(24);
    doc.setFont('helvetica', 'bold');
    doc.text('Device Status Report', 105, 20, { align: 'center' });
    
    doc.setFontSize(12);
    doc.setFont('helvetica', 'normal');
    doc.text(config.title, 105, 30, { align: 'center' });

    doc.setTextColor(0, 0, 0);
    yPos = 50;

    // Report Info
    doc.setFontSize(9);
    doc.text(`Generated: ${dayjs().format('MMMM D, YYYY [at] h:mm A')}`, 20, yPos);
    yPos += 5;
    doc.text(`Generated By: ${config.generatedBy}`, 20, yPos);
    yPos += 10;

    // Device Summary
    const selectedDevices = devices.filter(d => config.deviceIds.includes(d.deviceId));
    const onlineDevices = selectedDevices.filter(d => d.status === 'online').length;
    const offlineDevices = selectedDevices.filter(d => d.status === 'offline').length;
    const errorDevices = selectedDevices.filter(d => d.status === 'error').length;

    doc.setFontSize(10);
    doc.setFont('helvetica', 'bold');
    doc.text('Device Overview', 20, yPos);
    yPos += 7;

    autoTable(doc, {
      startY: yPos,
      head: [['Status', 'Count', 'Percentage']],
      body: [
        ['Online', onlineDevices.toString(), selectedDevices.length > 0 ? `${((onlineDevices / selectedDevices.length) * 100).toFixed(1)}%` : '0.0%'],
        ['Offline', offlineDevices.toString(), selectedDevices.length > 0 ? `${((offlineDevices / selectedDevices.length) * 100).toFixed(1)}%` : '0.0%'],
        ['Error', errorDevices.toString(), selectedDevices.length > 0 ? `${((errorDevices / selectedDevices.length) * 100).toFixed(1)}%` : '0.0%'],
        ['Total', selectedDevices.length.toString(), '100%'],
      ],
      styles: { fontSize: 9, cellPadding: 3 },
      headStyles: { fillColor: [0, 31, 63] },
      alternateRowStyles: { fillColor: [245, 245, 245] },
    });

    yPos = (doc as any).lastAutoTable.finalY + 10;

    // Device Details
    doc.setFontSize(10);
    doc.setFont('helvetica', 'bold');
    doc.text('Device Details', 20, yPos);
    yPos += 7;

    const deviceData = selectedDevices.map(device => [
      device.deviceId,
      device.name,
      device.type,
      device.status.toUpperCase(),
      device.firmwareVersion,
      dayjs(device.lastSeen).format('MMM D, YYYY HH:mm'),
    ]);

    autoTable(doc, {
      startY: yPos,
      head: [['Device ID', 'Name', 'Type', 'Status', 'Firmware', 'Last Seen']],
      body: deviceData,
      styles: { fontSize: 8, cellPadding: 2 },
      headStyles: { fillColor: [0, 31, 63] },
      alternateRowStyles: { fillColor: [245, 245, 245] },
      columnStyles: {
        3: { 
          fontStyle: 'bold',
        }
      },
      didParseCell: function(data: any) {
        if (data.column.index === 3) {
          const status = data.cell.raw.toLowerCase();
          if (status === 'online') {
            data.cell.styles.textColor = [82, 196, 26];
          } else if (status === 'offline') {
            data.cell.styles.textColor = [128, 128, 128];
          } else {
            data.cell.styles.textColor = [255, 77, 79];
          }
        }
      },
    });

    // Footer
    const pageCount = doc.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      doc.setFontSize(8);
      doc.setTextColor(128, 128, 128);
      doc.text(`Page ${i} of ${pageCount}`, 105, 285, { align: 'center' });
      doc.text(
        `IoT Device Management System - ${dayjs().format('YYYY')}`,
        105,
        290,
        { align: 'center' }
      );
    }

    return doc;
  };

  const handleGenerateReport = async (values: any) => {
    setGenerating(true);
    
    try {
      const config: ReportConfig = {
        type: selectedType,
        title: values.title || 'System Report',
        deviceIds: values.devices || [],
        dateRange: values.dateRange || null,
        includeCharts: values.includeCharts || false,
        includeRawData: values.includeRawData || true,
        includeStatistics: values.includeStatistics || true,
        notes: values.notes || '',
        generatedBy: 'Admin User',
      };

      if (config.deviceIds.length === 0) {
        message.warning('Please select at least one device');
        setGenerating(false);
        return;
      }

      // Load sensor data
      let allSensorData: SensorReading[] = [];
      
      for (const deviceId of config.deviceIds) {
        const data = await api.getSensorHistory(deviceId, 100);
        allSensorData.push(...data);
      }

      // Filter by date range if specified
      if (config.dateRange) {
        const startTime = config.dateRange[0].valueOf();
        const endTime = config.dateRange[1].valueOf();
        allSensorData = allSensorData.filter(
          d => d.timestamp >= startTime && d.timestamp <= endTime
        );
      }

      let doc: jsPDF;

      // Generate appropriate report
      switch (selectedType) {
        case 'water-quality':
          doc = await generateWaterQualityReport(config, allSensorData);
          break;
        case 'device-status':
          doc = await generateDeviceStatusReport(config);
          break;
        default:
          doc = await generateWaterQualityReport(config, allSensorData);
      }

      // Save PDF
      const filename = `${config.type}-report-${dayjs().format('YYYY-MM-DD-HHmmss')}.pdf`;
      doc.save(filename);

      // Add to history
      const newReport: ReportHistory = {
        id: Date.now().toString(),
        type: config.title,
        title: config.title,
        generatedAt: new Date(),
        devices: config.deviceIds.length,
        pages: doc.getNumberOfPages(),
      };
      setReportHistory([newReport, ...reportHistory]);

      message.success('Report generated successfully!');
    } catch (error) {
      console.error('Error generating report:', error);
      message.error('Failed to generate report');
    } finally {
      setGenerating(false);
    }
  };

  const reportTypes = [
    {
      key: 'water-quality',
      title: 'Water Quality Report',
      description: 'Comprehensive analysis of water quality parameters including turbidity, TDS, and pH levels',
      icon: <ExperimentOutlined />,
      color: '#1890ff',
    },
    {
      key: 'device-status',
      title: 'Device Status Report',
      description: 'Overview of all device statuses, connectivity, and operational health',
      icon: <DatabaseOutlined />,
      color: '#52c41a',
    },
    {
      key: 'data-summary',
      title: 'Data Summary Report',
      description: 'Statistical summary of sensor data over selected time period',
      icon: <BarChartOutlined />,
      color: '#722ed1',
    },
    {
      key: 'compliance',
      title: 'Compliance Report',
      description: 'Regulatory compliance assessment and quality standards verification',
      icon: <CheckCircleOutlined />,
      color: '#faad14',
    },
  ];

  return (
    <AdminLayout>
      <div style={{ padding: '24px' }}>
        {/* Header */}
        <Row justify="space-between" align="middle" style={{ marginBottom: 24 }}>
          <Col>
            <Title level={2}>
              <FileTextOutlined /> Report Management
            </Title>
            <Text type="secondary">
              Generate professional PDF reports for water quality analysis and device monitoring
            </Text>
          </Col>
        </Row>

        {/* Report Type Selection */}
        <Card title="Select Report Type" style={{ marginBottom: 24 }}>
          <Row gutter={[16, 16]}>
            {reportTypes.map(type => (
              <Col xs={24} sm={12} lg={6} key={type.key}>
                <Card
                  hoverable
                  onClick={() => setSelectedType(type.key as ReportType)}
                  style={{
                    borderColor: selectedType === type.key ? type.color : undefined,
                    borderWidth: selectedType === type.key ? 2 : 1,
                  }}
                >
                  <Space direction="vertical" style={{ width: '100%' }} align="center">
                    <div style={{ fontSize: 32, color: type.color }}>
                      {type.icon}
                    </div>
                    <Text strong>{type.title}</Text>
                    <Text type="secondary" style={{ fontSize: 12, textAlign: 'center' }}>
                      {type.description}
                    </Text>
                    {selectedType === type.key && (
                      <Tag color={type.color}>Selected</Tag>
                    )}
                  </Space>
                </Card>
              </Col>
            ))}
          </Row>
        </Card>

        {/* Report Configuration */}
        <Row gutter={16}>
          <Col xs={24} lg={16}>
            <Card
              title={
                <Space>
                  <FilePdfOutlined />
                  <span>Report Configuration</span>
                </Space>
              }
            >
              <Form
                form={form}
                layout="vertical"
                onFinish={handleGenerateReport}
                initialValues={{
                  includeStatistics: true,
                  includeRawData: true,
                  includeCharts: false,
                }}
              >
                <Form.Item
                  label="Report Title"
                  name="title"
                  rules={[{ required: true, message: 'Please enter report title' }]}
                >
                  <Input placeholder="e.g., Monthly Water Quality Report" />
                </Form.Item>

                <Form.Item
                  label="Select Devices"
                  name="devices"
                  rules={[{ required: true, message: 'Please select at least one device' }]}
                >
                  <Select
                    mode="multiple"
                    placeholder="Select devices to include"
                    loading={loading}
                    showSearch
                    filterOption={(input, option) =>
                      (option?.label ?? '').toLowerCase().includes(input.toLowerCase())
                    }
                    options={devices.map(device => ({
                      value: device.deviceId,
                      label: `${device.name} (${device.deviceId})`,
                    }))}
                  />
                </Form.Item>

                <Form.Item label="Date Range" name="dateRange">
                  <RangePicker
                    style={{ width: '100%' }}
                    format="YYYY-MM-DD"
                    presets={[
                      { label: 'Last 7 Days', value: [dayjs().subtract(7, 'd'), dayjs()] },
                      { label: 'Last 30 Days', value: [dayjs().subtract(30, 'd'), dayjs()] },
                      { label: 'Last 90 Days', value: [dayjs().subtract(90, 'd'), dayjs()] },
                      { label: 'This Year', value: [dayjs().startOf('year'), dayjs()] },
                    ]}
                  />
                </Form.Item>

                <Form.Item label="Report Options">
                  <Space direction="vertical">
                    <Form.Item name="includeStatistics" valuePropName="checked" noStyle>
                      <Checkbox>Include Statistical Summary</Checkbox>
                    </Form.Item>
                    <Form.Item name="includeRawData" valuePropName="checked" noStyle>
                      <Checkbox>Include Detailed Data Tables</Checkbox>
                    </Form.Item>
                    <Form.Item name="includeCharts" valuePropName="checked" noStyle>
                      <Checkbox disabled>Include Charts & Graphs (Coming Soon)</Checkbox>
                    </Form.Item>
                  </Space>
                </Form.Item>

                <Form.Item label="Additional Notes" name="notes">
                  <TextArea
                    rows={4}
                    placeholder="Add any additional notes or observations to include in the report..."
                  />
                </Form.Item>

                <Form.Item>
                  <Space>
                    <Button
                      type="primary"
                      htmlType="submit"
                      icon={<DownloadOutlined />}
                      loading={generating}
                      size="large"
                    >
                      Generate PDF Report
                    </Button>
                    <Button icon={<PrinterOutlined />} disabled>
                      Print Preview
                    </Button>
                  </Space>
                </Form.Item>
              </Form>
            </Card>
          </Col>

          {/* Report Preview & History */}
          <Col xs={24} lg={8}>
            <Space direction="vertical" style={{ width: '100%' }} size="large">
              {/* Quick Stats */}
              <Card>
                <Statistic
                  title="Reports Generated"
                  value={reportHistory.length}
                  prefix={<FileTextOutlined />}
                  valueStyle={{ color: '#001f3f' }}
                />
              </Card>

              {/* Report History */}
              <Card
                title={
                  <Space>
                    <HistoryOutlined />
                    <span>Recent Reports</span>
                  </Space>
                }
              >
                {reportHistory.length === 0 ? (
                  <Empty
                    description="No reports generated yet"
                    image={Empty.PRESENTED_IMAGE_SIMPLE}
                  />
                ) : (
                  <List
                    dataSource={reportHistory}
                    renderItem={item => (
                      <List.Item>
                        <List.Item.Meta
                          avatar={<FilePdfOutlined style={{ fontSize: 24, color: '#ff4d4f' }} />}
                          title={item.title}
                          description={
                            <Space direction="vertical" size={0}>
                              <Text type="secondary" style={{ fontSize: 12 }}>
                                {dayjs(item.generatedAt).format('MMM D, YYYY h:mm A')}
                              </Text>
                              <Space size={4}>
                                <Tag color="blue">{item.devices} devices</Tag>
                                <Tag color="green">{item.pages} pages</Tag>
                              </Space>
                            </Space>
                          }
                        />
                      </List.Item>
                    )}
                  />
                )}
              </Card>

              {/* Help Card */}
              <Alert
                message="Report Generation Tips"
                description={
                  <ul style={{ margin: 0, paddingLeft: 20 }}>
                    <li>Select relevant devices for focused reports</li>
                    <li>Use date ranges for specific time periods</li>
                    <li>Include statistics for executive summaries</li>
                    <li>Add notes for context and observations</li>
                  </ul>
                }
                type="info"
                showIcon
              />
            </Space>
          </Col>
        </Row>
      </div>
    </AdminLayout>
  );
};

export default ManageReports;
