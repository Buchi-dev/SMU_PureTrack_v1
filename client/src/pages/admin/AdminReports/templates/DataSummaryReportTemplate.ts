import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import dayjs from 'dayjs';
import type { ReportConfig, SensorReading } from '../../../../schemas';
import { calculateStatistics, calculateDataCompleteness } from '../utils';

// Type extension for jsPDF with autoTable plugin
interface jsPDFWithAutoTable extends jsPDF {
  lastAutoTable?: {
    finalY: number;
  };
}

export const generateDataSummaryReport = async (
  config: ReportConfig,
  reportData: any
): Promise<jsPDF> => {
  const doc = new jsPDF();
  let yPos = 20;

  // Header
  doc.setFillColor(0, 31, 63);
  doc.rect(0, 0, 210, 40, 'F');
  
  doc.setTextColor(255, 255, 255);
  doc.setFontSize(24);
  doc.setFont('helvetica', 'bold');
  doc.text('Data Summary Report', 105, 20, { align: 'center' });
  
  doc.setFontSize(12);
  doc.setFont('helvetica', 'normal');
  doc.text(config.title, 105, 30, { align: 'center' });

  doc.setTextColor(0, 0, 0);
  yPos = 50;

  // Report metadata
  doc.setFontSize(9);
  doc.text(`Generated: ${dayjs().format('MMMM D, YYYY [at] h:mm A')}`, 20, yPos);
  yPos += 5;
  doc.text(`Generated By: ${config.generatedBy}`, 20, yPos);
  yPos += 10;

  // Summary statistics from backend or calculated locally
  let summaryData = reportData.summary;
  
  // If no backend summary, calculate from local data
  if (!summaryData && reportData.devices && reportData.devices.length > 0) {
    const allReadings: SensorReading[] = [];
    reportData.devices.forEach((device: any) => {
      if (device.readings && Array.isArray(device.readings)) {
        allReadings.push(...device.readings);
      }
    });
    
    summaryData = {
      totalReadings: allReadings.length,
      totalDevices: reportData.devices.length,
      dataCompleteness: calculateDataCompleteness(
        allReadings.length,
        reportData.period?.start,
        reportData.period?.end
      ),
    };
  }
  
  if (summaryData) {
    doc.setFontSize(10);
    doc.setFont('helvetica', 'bold');
    doc.text('Data Summary', 20, yPos);
    yPos += 7;

    autoTable(doc, {
      startY: yPos,
      head: [['Metric', 'Value']],
      body: [
        ['Total Readings', summaryData.totalReadings?.toString() || 'N/A'],
        ['Total Devices', summaryData.totalDevices?.toString() || 'N/A'],
        ['Data Completeness', summaryData.dataCompleteness || 'N/A'],
      ],
      styles: { fontSize: 9, cellPadding: 3 },
      headStyles: { fillColor: [0, 31, 63] },
      alternateRowStyles: { fillColor: [245, 245, 245] },
    });

    yPos = (doc as jsPDFWithAutoTable).lastAutoTable?.finalY ?? yPos + 10;
  }

  // Statistical analysis from backend
  if (reportData.statistics) {
    doc.setFontSize(10);
    doc.setFont('helvetica', 'bold');
    doc.text('Statistical Analysis', 20, yPos);
    yPos += 7;

    const stats = reportData.statistics;
    const statsData = [];

    if (stats.turbidity) {
      statsData.push(['Turbidity', 'Mean', stats.turbidity.mean?.toFixed(2) || 'N/A', 'NTU']);
      statsData.push(['', 'Std Dev', stats.turbidity.stdDev?.toFixed(2) || 'N/A', 'NTU']);
      statsData.push(['', 'Min/Max', `${stats.turbidity.min?.toFixed(2) || 'N/A'} / ${stats.turbidity.max?.toFixed(2) || 'N/A'}`, 'NTU']);
    }

    if (stats.tds) {
      statsData.push(['TDS', 'Mean', stats.tds.mean?.toFixed(2) || 'N/A', 'ppm']);
      statsData.push(['', 'Std Dev', stats.tds.stdDev?.toFixed(2) || 'N/A', 'ppm']);
      statsData.push(['', 'Min/Max', `${stats.tds.min?.toFixed(2) || 'N/A'} / ${stats.tds.max?.toFixed(2) || 'N/A'}`, 'ppm']);
    }

    if (stats.ph) {
      statsData.push(['pH', 'Mean', stats.ph.mean?.toFixed(2) || 'N/A', '']);
      statsData.push(['', 'Std Dev', stats.ph.stdDev?.toFixed(2) || 'N/A', '']);
      statsData.push(['', 'Min/Max', `${stats.ph.min?.toFixed(2) || 'N/A'} / ${stats.ph.max?.toFixed(2) || 'N/A'}`, '']);
    }

    if (statsData.length > 0) {
      autoTable(doc, {
        startY: yPos,
        head: [['Parameter', 'Statistic', 'Value', 'Unit']],
        body: statsData,
        styles: { fontSize: 8, cellPadding: 2 },
        headStyles: { fillColor: [0, 31, 63] },
        alternateRowStyles: { fillColor: [245, 245, 245] },
      });
      
      yPos = (doc as jsPDFWithAutoTable).lastAutoTable?.finalY ?? yPos + 10;
    }
  } else if (reportData.devices && reportData.devices.length > 0) {
    // Fallback: Calculate statistics from device readings if no backend statistics available
    doc.setFontSize(10);
    doc.setFont('helvetica', 'bold');
    doc.text('Statistical Analysis (Local Data)', 20, yPos);
    yPos += 7;
    
    // Collect all readings from all devices
    const allReadings: SensorReading[] = [];
    reportData.devices.forEach((device: any) => {
      if (device.readings && Array.isArray(device.readings)) {
        allReadings.push(...device.readings);
      }
    });
    
    if (allReadings.length > 0) {
      const turbidityData = allReadings.map((r: SensorReading) => r.turbidity);
      const tdsData = allReadings.map((r: SensorReading) => r.tds);
      const phData = allReadings.map((r: SensorReading) => r.ph);
      
      const turbidityStats = calculateStatistics(turbidityData);
      const tdsStats = calculateStatistics(tdsData);
      const phStats = calculateStatistics(phData);
      
      const fallbackStatsData = [
        ['Turbidity', 'Mean', turbidityStats.mean.toFixed(2), 'NTU'],
        ['', 'Std Dev', turbidityStats.stdDev.toFixed(2), 'NTU'],
        ['', 'Min/Max', `${turbidityStats.min.toFixed(2)} / ${turbidityStats.max.toFixed(2)}`, 'NTU'],
        ['TDS', 'Mean', tdsStats.mean.toFixed(2), 'ppm'],
        ['', 'Std Dev', tdsStats.stdDev.toFixed(2), 'ppm'],
        ['', 'Min/Max', `${tdsStats.min.toFixed(2)} / ${tdsStats.max.toFixed(2)}`, 'ppm'],
        ['pH', 'Mean', phStats.mean.toFixed(2), ''],
        ['', 'Std Dev', phStats.stdDev.toFixed(2), ''],
        ['', 'Min/Max', `${phStats.min.toFixed(2)} / ${phStats.max.toFixed(2)}`, ''],
      ];
      
      autoTable(doc, {
        startY: yPos,
        head: [['Parameter', 'Statistic', 'Value', 'Unit']],
        body: fallbackStatsData,
        styles: { fontSize: 8, cellPadding: 2 },
        headStyles: { fillColor: [0, 31, 63] },
        alternateRowStyles: { fillColor: [245, 245, 245] },
      });
      
      yPos = (doc as jsPDFWithAutoTable).lastAutoTable?.finalY ?? yPos + 10;
    } else {
      doc.setFontSize(9);
      doc.setFont('helvetica', 'normal');
      doc.text('No sensor data available for statistical analysis.', 20, yPos);
      yPos += 10;
    }
  }

  // Add footer
  const pageCount = doc.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(8);
    doc.setTextColor(128, 128, 128);
    doc.text(`Page ${i} of ${pageCount}`, 105, 285, { align: 'center' });
    doc.text(
      `IoT Data Analysis System - ${dayjs().format('YYYY')}`,
      105,
      290,
      { align: 'center' }
    );
  }

  return doc;
};
