import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import dayjs from 'dayjs';
import type { ReportConfig } from '../../../../schemas';

// ============================================================================
// CONSTANTS - Design System
// ============================================================================
const COLORS = {
  primary: { r: 0, g: 31, b: 63 },        // Navy Blue
  secondary: { r: 41, g: 128, b: 185 },   // Light Blue
  success: { r: 82, g: 196, b: 26 },      // Green
  warning: { r: 250, g: 173, b: 20 },     // Orange
  danger: { r: 255, g: 77, b: 79 },       // Red
  gray: { r: 128, g: 128, b: 128 },       // Gray
  lightGray: { r: 245, g: 245, b: 245 },  // Light Gray
  white: { r: 255, g: 255, b: 255 },      // White
  black: { r: 0, g: 0, b: 0 },            // Black
  text: { r: 51, g: 51, b: 51 },          // Dark Gray Text
  textSecondary: { r: 128, g: 128, b: 128 }, // Gray Text
};

const SPACING = {
  page: { top: 20, bottom: 25, left: 15, right: 15 },
  section: 12,
  paragraph: 6,
  line: 5,
};

const FONTS = {
  title: { size: 24, style: 'bold' },
  subtitle: { size: 14, style: 'normal' },
  heading: { size: 12, style: 'bold' },
  subheading: { size: 10, style: 'bold' },
  body: { size: 9, style: 'normal' },
  small: { size: 8, style: 'normal' },
  tiny: { size: 7, style: 'normal' },
};

// Type extension for jsPDF with autoTable plugin
interface jsPDFWithAutoTable extends jsPDF {
  lastAutoTable?: {
    finalY: number;
  };
}

export const generateWaterQualityReport = async (
  config: ReportConfig,
  reportData: any
): Promise<jsPDF> => {
  const doc = new jsPDF({
    orientation: 'portrait',
    unit: 'mm',
    format: 'a4',
  });
  
  const reportId = `WQR-${dayjs().format('YYYYMMDD')}-${Math.random().toString(36).substr(2, 6).toUpperCase()}`;
  let yPos = 0;

  // ============================================================================
  // HEADER SECTION - Professional Dark Blue Header
  // ============================================================================
  
  // Main header bar
  doc.setFillColor(COLORS.primary.r, COLORS.primary.g, COLORS.primary.b);
  doc.rect(0, 0, 210, 50, 'F');
  
  // Header content
  doc.setTextColor(COLORS.white.r, COLORS.white.g, COLORS.white.b);
  doc.setFont('helvetica', FONTS.title.style);
  doc.setFontSize(FONTS.title.size);
  doc.text('Water Quality Analysis Report', 105, 22, { align: 'center' });
  
  doc.setFont('helvetica', FONTS.subtitle.style);
  doc.setFontSize(FONTS.subtitle.size);
  doc.text(config.title || 'Comprehensive Water Quality Assessment', 105, 32, { align: 'center' });
  
  // Report ID badge
  doc.setFont('helvetica', FONTS.small.style);
  doc.setFontSize(FONTS.small.size);
  doc.text(`Report ID: ${reportId}`, 105, 42, { align: 'center' });

  // Accent line under header
  doc.setFillColor(COLORS.secondary.r, COLORS.secondary.g, COLORS.secondary.b);
  doc.rect(0, 50, 210, 2, 'F');

  yPos = 60;

  // ============================================================================
  // REPORT INFORMATION CARD - Professional Information Box
  // ============================================================================
  
  doc.setTextColor(COLORS.text.r, COLORS.text.g, COLORS.text.b);
  
  // Information card background
  doc.setFillColor(COLORS.lightGray.r, COLORS.lightGray.g, COLORS.lightGray.b);
  doc.roundedRect(SPACING.page.left, yPos, 180, 38, 2, 2, 'F');
  
  // Border for card
  doc.setDrawColor(COLORS.gray.r, COLORS.gray.g, COLORS.gray.b);
  doc.setLineWidth(0.3);
  doc.roundedRect(SPACING.page.left, yPos, 180, 38, 2, 2, 'S');
  
  yPos += 7;
  
  // Section title
  doc.setFont('helvetica', FONTS.subheading.style);
  doc.setFontSize(FONTS.subheading.size);
  doc.setTextColor(COLORS.primary.r, COLORS.primary.g, COLORS.primary.b);
  doc.text('Report Information', SPACING.page.left + 5, yPos);
  doc.setTextColor(COLORS.text.r, COLORS.text.g, COLORS.text.b);
  yPos += 7;

  // Two-column layout for information
  doc.setFont('helvetica', FONTS.body.style);
  doc.setFontSize(FONTS.body.size);
  
  const col1X = SPACING.page.left + 5;
  const col2X = 110;
  
  // Column 1
  doc.text(`Generated: ${dayjs().format('MMMM D, YYYY [at] h:mm A')}`, col1X, yPos);
  doc.text(`Generated By: ${config.generatedBy || 'System Administrator'}`, col1X, yPos + 5);
  doc.text(`Devices Monitored: ${reportData.devices?.length || config.deviceIds.length}`, col1X, yPos + 10);
  
  // Column 2
  if (reportData.period) {
    doc.text(`Report Period:`, col2X, yPos);
    doc.text(`${dayjs(reportData.period.start).format('MMM D, YYYY')} - ${dayjs(reportData.period.end).format('MMM D, YYYY')}`, col2X, yPos + 5);
  }
  doc.text(`Total Readings: ${reportData.summary?.totalReadings || 0}`, col2X, yPos + 10);
  
  yPos += 17;
  
  // Notes section (if present)
  if (config.notes) {
    doc.setFont('helvetica', FONTS.small.style);
    doc.setFontSize(FONTS.small.size);
    doc.setTextColor(COLORS.gray.r, COLORS.gray.g, COLORS.gray.b);
    const notesText = `Notes: ${config.notes}`;
    const splitNotes = doc.splitTextToSize(notesText, 170);
    doc.text(splitNotes, col1X, yPos);
    yPos += (splitNotes.length * 4);
  }
  
  yPos += 10;

  // ============================================================================
  // REGULATORY STANDARDS SECTION - WHO Guidelines Reference
  // ============================================================================
  if (yPos > 240) {
    doc.addPage();
    yPos = SPACING.page.top;
  }

  // Section header
  doc.setFont('helvetica', 'bold');
  doc.setFontSize(12);
  doc.setTextColor(COLORS.primary.r, COLORS.primary.g, COLORS.primary.b);
  doc.text('Regulatory Standards Reference', SPACING.page.left, yPos);
  
  // Decorative underline
  doc.setDrawColor(COLORS.secondary.r, COLORS.secondary.g, COLORS.secondary.b);
  doc.setLineWidth(0.8);
  doc.line(SPACING.page.left, yPos + 2, SPACING.page.left + 70, yPos + 2);
  
  yPos += 10;

  // Standards table with WHO guidelines
  const standardsData = [
    ['Turbidity', '< 5 NTU', 'WHO Guidelines for Drinking Water', 'Aesthetic quality indicator'],
    ['TDS (Total Dissolved Solids)', '< 500 ppm', 'WHO Guidelines for Drinking Water', 'Taste and health indicator'],
    ['pH Level', '6.5 - 8.5', 'WHO Guidelines for Drinking Water', 'Acidity/alkalinity balance'],
  ];
  
  autoTable(doc, {
    startY: yPos,
    head: [['Parameter', 'Standard Limit', 'Reference', 'Description']],
    body: standardsData,
    styles: { 
      fontSize: FONTS.small.size,
      cellPadding: 3,
      lineColor: [COLORS.gray.r, COLORS.gray.g, COLORS.gray.b],
      lineWidth: 0.1,
    },
    headStyles: { 
      fillColor: [COLORS.primary.r, COLORS.primary.g, COLORS.primary.b],
      textColor: [COLORS.white.r, COLORS.white.g, COLORS.white.b],
      fontStyle: 'bold',
      fontSize: FONTS.body.size,
    },
    alternateRowStyles: { 
      fillColor: [COLORS.lightGray.r, COLORS.lightGray.g, COLORS.lightGray.b]
    },
    columnStyles: {
      0: { fontStyle: 'bold', cellWidth: 50 },
      1: { cellWidth: 28 },
      2: { cellWidth: 45 },
      3: { cellWidth: 52 },
    },
    margin: { left: SPACING.page.left, right: SPACING.page.right },
  });
  
  yPos = (doc as jsPDFWithAutoTable).lastAutoTable?.finalY ?? yPos + 10;
  yPos += SPACING.section;

  // ============================================================================
  // EXECUTIVE SUMMARY WITH COMPLIANCE METRICS
  // ============================================================================
  if (reportData.summary) {
    if (yPos > 220) {
      doc.addPage();
      yPos = SPACING.page.top;
    }

    // Section header
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(12);
    doc.setTextColor(COLORS.primary.r, COLORS.primary.g, COLORS.primary.b);
    doc.text('Executive Summary & Compliance Overview', SPACING.page.left, yPos);
    
    // Decorative underline
    doc.setDrawColor(COLORS.secondary.r, COLORS.secondary.g, COLORS.secondary.b);
    doc.setLineWidth(0.8);
    doc.line(SPACING.page.left, yPos + 2, SPACING.page.left + 50, yPos + 2);
    
    yPos += 10;

    const summary = reportData.summary;
    const overallStatus = getOverallStatus(summary);
    const complianceMetrics = calculateComplianceMetrics(summary);

    // Status badge with rounded corners - WIDER (full 180mm)
    const badgeHeight = 35;
    doc.setFillColor(overallStatus.color[0], overallStatus.color[1], overallStatus.color[2]);
    doc.roundedRect(SPACING.page.left, yPos, 180, badgeHeight, 3, 3, 'F');
    
    // Status title (larger, bolder)
    doc.setTextColor(COLORS.white.r, COLORS.white.g, COLORS.white.b);
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(14);
    doc.text(`Overall Water Quality: ${overallStatus.status}`, SPACING.page.left + 5, yPos + 10);
    
    // Check if we have actual data
    const hasData = summary.averageTurbidity !== undefined && 
                    summary.totalReadings > 0;

    // Add summary stats in badge (smaller text, three rows)
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(FONTS.small.size);
    
    if (hasData) {
      doc.text(
        `Turbidity: ${summary.averageTurbidity.toFixed(2)} NTU | TDS: ${summary.averageTDS.toFixed(2)} ppm | pH: ${summary.averagePH.toFixed(2)} | Total Readings: ${summary.totalReadings}`, 
        SPACING.page.left + 5, 
        yPos + 18
      );
      doc.text(
        `Period: ${reportData.period || 'N/A'} | Devices Monitored: ${reportData.devices?.length || 0}`, 
        SPACING.page.left + 5, 
        yPos + 24
      );
      // Compliance metrics row
      doc.setFont('helvetica', 'bold');
      doc.text(
        `Compliance Rate: ${complianceMetrics.rate}% | Compliant Parameters: ${complianceMetrics.compliantCount}/${complianceMetrics.totalCount}`, 
        SPACING.page.left + 5, 
        yPos + 30
      );
    } else {
      doc.text('No sensor data available for the selected period', SPACING.page.left + 5, yPos + 18);
    }

    yPos += badgeHeight + 10;
    doc.setTextColor(COLORS.text.r, COLORS.text.g, COLORS.text.b);
  }

  // ============================================================================
  // DEVICE ANALYSIS - Detailed Metrics Per Device
  // ============================================================================
  if (reportData.devices && reportData.devices.length > 0) {
    if (yPos > 240) {
      doc.addPage();
      yPos = SPACING.page.top;
    }

    // Section header
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(12);
    doc.setTextColor(COLORS.primary.r, COLORS.primary.g, COLORS.primary.b);
    doc.text('Device Analysis', SPACING.page.left, yPos);
    
    // Decorative underline
    doc.setDrawColor(COLORS.secondary.r, COLORS.secondary.g, COLORS.secondary.b);
    doc.setLineWidth(0.8);
    doc.line(SPACING.page.left, yPos + 2, SPACING.page.left + 40, yPos + 2);
    
    yPos += 10;

    for (const deviceReport of reportData.devices) {
      if (yPos > 240) {
        doc.addPage();
        yPos = SPACING.page.top;
      }

      // Device header card with proper height
      const deviceHeaderHeight = 12;
      doc.setFillColor(COLORS.lightGray.r, COLORS.lightGray.g, COLORS.lightGray.b);
      doc.roundedRect(SPACING.page.left, yPos, 180, deviceHeaderHeight, 2, 2, 'F');
      doc.setDrawColor(COLORS.gray.r, COLORS.gray.g, COLORS.gray.b);
      doc.setLineWidth(0.2);
      doc.roundedRect(SPACING.page.left, yPos, 180, deviceHeaderHeight, 2, 2, 'S');
      
      // Device name (left side)
      doc.setFont('helvetica', 'bold');
      doc.setFontSize(FONTS.subheading.size);
      doc.setTextColor(COLORS.primary.r, COLORS.primary.g, COLORS.primary.b);
      const deviceName = deviceReport.deviceName || deviceReport.deviceId || 'Unknown Device';
      doc.text(`Device: ${deviceName}`, SPACING.page.left + 3, yPos + 7.5);
      
      // Location (right side) with proper text wrapping
      if (deviceReport.location) {
        doc.setFont('helvetica', 'normal');
        doc.setFontSize(FONTS.small.size);
        doc.setTextColor(COLORS.textSecondary.r, COLORS.textSecondary.g, COLORS.textSecondary.b);
        const locationText = `Location: ${deviceReport.location}`;
        const maxLocationWidth = 70;
        const wrappedLocation = doc.splitTextToSize(locationText, maxLocationWidth);
        doc.text(wrappedLocation[0], SPACING.page.left + 105, yPos + 7.5);
      }
      
      yPos += deviceHeaderHeight + 5;

      // Check if device has any readings
      if (!deviceReport.metrics || deviceReport.metrics.totalReadings === 0) {
        // Show warning card for no data
        doc.setFillColor(255, 250, 230); // Light yellow background
        doc.roundedRect(SPACING.page.left, yPos, 180, 15, 2, 2, 'F');
        doc.setDrawColor(COLORS.warning.r, COLORS.warning.g, COLORS.warning.b);
        doc.setLineWidth(0.3);
        doc.roundedRect(SPACING.page.left, yPos, 180, 15, 2, 2, 'S');
        
        doc.setFont('helvetica', 'normal');
        doc.setFontSize(FONTS.body.size);
        doc.setTextColor(COLORS.warning.r, COLORS.warning.g, COLORS.warning.b);
        doc.text('No sensor data available for this device in the selected period', 
          SPACING.page.left + 5, yPos + 9);
        
        yPos += 20;
        doc.setTextColor(COLORS.text.r, COLORS.text.g, COLORS.text.b);
        continue; // Skip to next device
      }

      // OPTIMIZED Metrics table - Maximizes PDF space (180mm full width)
      if (deviceReport.metrics) {
        const metrics = deviceReport.metrics;
        
        autoTable(doc, {
          startY: yPos,
          head: [['Parameter', 'Average Value', 'Min / Max Range', 'Safe Range', 'Status']],
          body: [
            [
              'Turbidity',
              `${metrics.avgTurbidity?.toFixed(2) || 'N/A'} NTU`,
              `${metrics.minTurbidity?.toFixed(2) || 'N/A'} / ${metrics.maxTurbidity?.toFixed(2) || 'N/A'}`,
              'Max: 5 NTU',
              (metrics.avgTurbidity || 0) <= 5 ? 'GOOD' : 'WARNING'
            ],
            [
              'TDS',
              `${metrics.avgTDS?.toFixed(2) || 'N/A'} ppm`,
              `${metrics.minTDS?.toFixed(2) || 'N/A'} / ${metrics.maxTDS?.toFixed(2) || 'N/A'}`,
              'Max: 500 ppm',
              (metrics.avgTDS || 0) <= 500 ? 'GOOD' : 'WARNING'
            ],
            [
              'pH Level',
              metrics.avgPH?.toFixed(2) || 'N/A',
              `${metrics.minPH?.toFixed(2) || 'N/A'} / ${metrics.maxPH?.toFixed(2) || 'N/A'}`,
              '6.5 - 8.5',
              ((metrics.avgPH || 0) >= 6.5 && (metrics.avgPH || 0) <= 8.5) ? 'GOOD' : 'WARNING'
            ],
          ],
          styles: { 
            fontSize: FONTS.body.size, 
            cellPadding: { top: 5, right: 4, bottom: 5, left: 4 },
            lineColor: [COLORS.gray.r, COLORS.gray.g, COLORS.gray.b],
            lineWidth: 0.15,
            halign: 'left',
            valign: 'middle',
            overflow: 'linebreak',
            minCellHeight: 11,
          },
          headStyles: { 
            fillColor: [COLORS.primary.r, COLORS.primary.g, COLORS.primary.b],
            textColor: [COLORS.white.r, COLORS.white.g, COLORS.white.b],
            fontSize: FONTS.body.size,
            fontStyle: 'bold',
            halign: 'center',
            valign: 'middle',
            minCellHeight: 11,
            cellPadding: { top: 5, right: 4, bottom: 5, left: 4 },
          },
          alternateRowStyles: { 
            fillColor: [COLORS.lightGray.r, COLORS.lightGray.g, COLORS.lightGray.b] 
          },
          columnStyles: {
            0: { fontStyle: 'bold', cellWidth: 32, halign: 'left' },    // Parameter - wider
            1: { cellWidth: 35, halign: 'center' },                      // Average - wider
            2: { cellWidth: 40, halign: 'center' },                      // Min/Max - wider for ranges
            3: { cellWidth: 35, halign: 'center' },                      // Safe Range - wider
            4: { 
              cellWidth: 38,                                              // Status - wider for full text
              fontStyle: 'bold',
              halign: 'center',
            }
          },
          didParseCell: function(data: any) {
            // Color-code Status column
            if (data.column.index === 4) {
              const status = String(data.cell.raw || '').toUpperCase();
              if (status.includes('GOOD')) {
                data.cell.styles.textColor = [COLORS.success.r, COLORS.success.g, COLORS.success.b];
                data.cell.styles.fillColor = [240, 255, 240]; // Light green background
              } else if (status.includes('WARNING')) {
                data.cell.styles.textColor = [COLORS.warning.r, COLORS.warning.g, COLORS.warning.b];
                data.cell.styles.fillColor = [255, 250, 230]; // Light yellow background
              } else {
                data.cell.styles.textColor = [COLORS.danger.r, COLORS.danger.g, COLORS.danger.b];
                data.cell.styles.fillColor = [255, 240, 240]; // Light red background
              }
            }
          },
          margin: { left: SPACING.page.left, right: SPACING.page.right },
          tableWidth: 'auto',
        });

        yPos = (doc as jsPDFWithAutoTable).lastAutoTable?.finalY ?? yPos + 10;
        yPos += 5;
      }

      // ========================================================================
      // COMPLIANCE DETAILS TABLE - Per-Parameter Compliance Percentages
      // ========================================================================
      if (deviceReport.metrics) {
        if (yPos > 230) {
          doc.addPage();
          yPos = SPACING.page.top;
        }

        const metrics = deviceReport.metrics;
        const complianceDetails = calculateDeviceCompliance(metrics);

        // Compliance section sub-header
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(FONTS.subheading.size);
        doc.setTextColor(COLORS.primary.r, COLORS.primary.g, COLORS.primary.b);
        doc.text('Compliance Analysis', SPACING.page.left, yPos);
        yPos += 6;

        // Compliance details table
        const complianceData = [
          [
            'Turbidity',
            complianceDetails.turbidity.value,
            complianceDetails.turbidity.standard,
            complianceDetails.turbidity.status,
            complianceDetails.turbidity.percentage
          ],
          [
            'TDS',
            complianceDetails.tds.value,
            complianceDetails.tds.standard,
            complianceDetails.tds.status,
            complianceDetails.tds.percentage
          ],
          [
            'pH',
            complianceDetails.ph.value,
            complianceDetails.ph.standard,
            complianceDetails.ph.status,
            complianceDetails.ph.percentage
          ],
        ];

        autoTable(doc, {
          startY: yPos,
          head: [['Parameter', 'Avg Value', 'WHO Standard', 'Status', 'Compliance %']],
          body: complianceData,
          styles: { 
            fontSize: FONTS.small.size,
            cellPadding: 3,
            lineColor: [COLORS.gray.r, COLORS.gray.g, COLORS.gray.b],
            lineWidth: 0.1,
            halign: 'center',
          },
          headStyles: { 
            fillColor: [COLORS.primary.r, COLORS.primary.g, COLORS.primary.b],
            textColor: [COLORS.white.r, COLORS.white.g, COLORS.white.b],
            fontSize: FONTS.body.size,
            fontStyle: 'bold',
          },
          alternateRowStyles: { 
            fillColor: [COLORS.lightGray.r, COLORS.lightGray.g, COLORS.lightGray.b]
          },
          columnStyles: {
            0: { fontStyle: 'bold', cellWidth: 40, halign: 'left' },
            1: { cellWidth: 30 },
            2: { cellWidth: 35 },
            3: { fontStyle: 'bold', cellWidth: 35 },
            4: { fontStyle: 'bold', cellWidth: 35 },
          },
          didParseCell: function(data: any) {
            // Color-code Status column (index 3)
            if (data.column.index === 3) {
              const status = String(data.cell.raw || '').toLowerCase();
              if (status === 'compliant') {
                data.cell.styles.textColor = [COLORS.success.r, COLORS.success.g, COLORS.success.b];
              } else if (status === 'non-compliant') {
                data.cell.styles.textColor = [COLORS.danger.r, COLORS.danger.g, COLORS.danger.b];
              } else {
                data.cell.styles.textColor = [COLORS.gray.r, COLORS.gray.g, COLORS.gray.b];
              }
            }
            // Color-code Compliance % column (index 4)
            if (data.column.index === 4) {
              const percentStr = String(data.cell.raw || '0%');
              const percentage = parseFloat(percentStr.replace('%', ''));
              if (percentage >= 90) {
                data.cell.styles.textColor = [COLORS.success.r, COLORS.success.g, COLORS.success.b];
              } else if (percentage >= 70) {
                data.cell.styles.textColor = [COLORS.warning.r, COLORS.warning.g, COLORS.warning.b];
              } else {
                data.cell.styles.textColor = [COLORS.danger.r, COLORS.danger.g, COLORS.danger.b];
              }
            }
          },
          margin: { left: SPACING.page.left, right: SPACING.page.right },
        });

        yPos = (doc as jsPDFWithAutoTable).lastAutoTable?.finalY ?? yPos + 10;
        yPos += 8;
      }

      // OPTIMIZED Alerts section - Organized by severity (CRITICAL → HIGH → MEDIUM → LOW)
      if (deviceReport.alerts && deviceReport.alerts.length > 0) {
        if (yPos > 230) {
          doc.addPage();
          yPos = SPACING.page.top;
        }

        // Sort alerts by severity priority
        const severityOrder: { [key: string]: number } = { 
          'critical': 1, 
          'high': 2, 
          'medium': 3, 
          'low': 4 
        };
        const sortedAlerts = [...deviceReport.alerts].sort((a, b) => {
          const severityA = (a.severity || 'low').toLowerCase();
          const severityB = (b.severity || 'low').toLowerCase();
          return (severityOrder[severityA] || 5) - (severityOrder[severityB] || 5);
        });

        // Count alerts by severity
        const criticalCount = sortedAlerts.filter(a => a.severity?.toLowerCase() === 'critical').length;
        const highCount = sortedAlerts.filter(a => a.severity?.toLowerCase() === 'high').length;
        const mediumCount = sortedAlerts.filter(a => a.severity?.toLowerCase() === 'medium').length;
        const lowCount = sortedAlerts.filter(a => a.severity?.toLowerCase() === 'low').length;

        // Alert section header with severity breakdown
        const alertHeaderHeight = 12;
        doc.setFillColor(255, 250, 240); // Light orange background
        doc.roundedRect(SPACING.page.left, yPos, 180, alertHeaderHeight, 2, 2, 'F');
        doc.setDrawColor(COLORS.warning.r, COLORS.warning.g, COLORS.warning.b);
        doc.setLineWidth(0.3);
        doc.roundedRect(SPACING.page.left, yPos, 180, alertHeaderHeight, 2, 2, 'S');
        
        // Title
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(FONTS.subheading.size);
        doc.setTextColor(COLORS.danger.r, COLORS.danger.g, COLORS.danger.b);
        doc.text(`Active Alerts: ${deviceReport.alerts.length}`, SPACING.page.left + 3, yPos + 5);
        
        // Severity breakdown (smaller text on second line)
        doc.setFont('helvetica', 'normal');
        doc.setFontSize(FONTS.tiny.size);
        doc.setTextColor(COLORS.textSecondary.r, COLORS.textSecondary.g, COLORS.textSecondary.b);
        const breakdownText = `Critical: ${criticalCount} | High: ${highCount} | Medium: ${mediumCount} | Low: ${lowCount}`;
        doc.text(breakdownText, SPACING.page.left + 3, yPos + 9);
        
        yPos += alertHeaderHeight + 5;

        // Display alerts in organized table format (max 10 alerts)
        const alertsToShow = sortedAlerts.slice(0, 10);
        const alertTableData = alertsToShow.map((alert: any) => {
          const severity = (alert.severity || 'low').toUpperCase();
          
          // Get message with fallback to description or location info
          let message = alert.message || alert.description || 'Alert triggered';
          if (alert.location && message.indexOf(alert.location) === -1) {
            message = `[${alert.location}] ${message}`;
          }
          
          // Format timestamp properly
          let timestamp = 'Just now';
          if (alert.timestamp) {
            try {
              timestamp = dayjs(alert.timestamp).format('MMM D, HH:mm');
            } catch (error) {
              timestamp = 'Recent';
            }
          }
          
          return [severity, message, timestamp];
        });

        autoTable(doc, {
          startY: yPos,
          head: [['Severity', 'Alert Message', 'Time']],
          body: alertTableData,
          styles: { 
            fontSize: FONTS.small.size,
            cellPadding: { top: 4, right: 4, bottom: 4, left: 4 },
            lineColor: [COLORS.gray.r, COLORS.gray.g, COLORS.gray.b],
            lineWidth: 0.15,
            halign: 'left',
            valign: 'middle',
            overflow: 'linebreak',
            minCellHeight: 10,
          },
          headStyles: { 
            fillColor: [COLORS.danger.r, COLORS.danger.g, COLORS.danger.b],
            textColor: [COLORS.white.r, COLORS.white.g, COLORS.white.b],
            fontSize: FONTS.body.size,
            fontStyle: 'bold',
            halign: 'center',
            cellPadding: { top: 5, right: 4, bottom: 5, left: 4 },
            minCellHeight: 11,
          },
          alternateRowStyles: {
            fillColor: [252, 252, 252] // Very light gray for alternating rows
          },
          columnStyles: {
            0: { 
              cellWidth: 28, 
              fontStyle: 'bold', 
              halign: 'center',
              fontSize: FONTS.small.size,
            },
            1: { 
              cellWidth: 117,  // Slightly adjusted for better fit
              halign: 'left',
              fontSize: FONTS.small.size,
            },
            2: { 
              cellWidth: 35, 
              halign: 'center',
              fontSize: FONTS.small.size,
              fontStyle: 'normal',
            }
          },
          didParseCell: function(data: any) {
            // Color-code Severity column with distinct backgrounds
            if (data.column.index === 0 && data.section === 'body') {
              const severity = String(data.cell.raw || '').toLowerCase();
              if (severity === 'critical') {
                data.cell.styles.fillColor = [255, 230, 230]; // Stronger light red
                data.cell.styles.textColor = [COLORS.danger.r, COLORS.danger.g, COLORS.danger.b];
              } else if (severity === 'high') {
                data.cell.styles.fillColor = [255, 240, 225]; // Stronger light orange
                data.cell.styles.textColor = [255, 87, 34]; // Deep orange
              } else if (severity === 'medium') {
                data.cell.styles.fillColor = [255, 248, 220]; // Stronger light yellow
                data.cell.styles.textColor = [COLORS.warning.r, COLORS.warning.g, COLORS.warning.b];
              } else {
                data.cell.styles.fillColor = [240, 248, 255]; // Stronger light blue
                data.cell.styles.textColor = [COLORS.secondary.r, COLORS.secondary.g, COLORS.secondary.b];
              }
            }
            
            // Style Time column with gray text
            if (data.column.index === 2 && data.section === 'body') {
              data.cell.styles.textColor = [COLORS.textSecondary.r, COLORS.textSecondary.g, COLORS.textSecondary.b];
            }
          },
          margin: { left: SPACING.page.left, right: SPACING.page.right },
          tableWidth: 'auto',
        });
        
        yPos = (doc as jsPDFWithAutoTable).lastAutoTable?.finalY ?? yPos + 10;
        
        // Show remaining alerts count if more than 10
        if (sortedAlerts.length > 10) {
          yPos += 3;
          doc.setFont('helvetica', 'italic');
          doc.setFontSize(FONTS.small.size);
          doc.setTextColor(COLORS.gray.r, COLORS.gray.g, COLORS.gray.b);
          doc.text(`+ ${sortedAlerts.length - 10} more alerts not shown (view in system for full list)`, SPACING.page.left + 5, yPos);
          yPos += 5;
        }
        
        yPos += 8;
      } else {
        yPos += 5;
      }
    }
  }

  // ============================================================================
  // RECOMMENDATIONS SECTION - Action Items
  // ============================================================================
  const hasIssues = reportData.devices?.some((d: any) => d.alerts && d.alerts.length > 0);
  if (hasIssues) {
    if (yPos > 220) {
      doc.addPage();
      yPos = SPACING.page.top;
    }

    // Section header
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(12);
    doc.setTextColor(COLORS.primary.r, COLORS.primary.g, COLORS.primary.b);
    doc.text('Recommendations & Action Items', SPACING.page.left, yPos);
    
    // Decorative underline
    doc.setDrawColor(COLORS.secondary.r, COLORS.secondary.g, COLORS.secondary.b);
    doc.setLineWidth(0.8);
    doc.line(SPACING.page.left, yPos + 2, SPACING.page.left + 80, yPos + 2);
    
    yPos += 10;

    doc.setFont('helvetica', 'normal');
    doc.setFontSize(9);
    doc.setTextColor(COLORS.text.r, COLORS.text.g, COLORS.text.b);
    
    const recommendations = generateRecommendations(reportData);
    recommendations.forEach((rec, index) => {
      if (yPos > 260) {
        doc.addPage();
        yPos = SPACING.page.top;
      }
      
      // Numbered recommendation with bullet icon
      doc.setTextColor(COLORS.secondary.r, COLORS.secondary.g, COLORS.secondary.b);
      doc.text(`${index + 1}.`, SPACING.page.left, yPos);
      doc.setTextColor(COLORS.text.r, COLORS.text.g, COLORS.text.b);
      
      const recLines = doc.splitTextToSize(rec, 170);
      doc.text(recLines, SPACING.page.left + 8, yPos);
      yPos += (recLines.length * 5) + 3;
    });
  }

  // ============================================================================
  // PROFESSIONAL FOOTER - Added to all pages
  // ============================================================================
  const pageCount = doc.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    
    // Footer separator line
    doc.setDrawColor(COLORS.gray.r, COLORS.gray.g, COLORS.gray.b);
    doc.setLineWidth(0.5);
    doc.line(SPACING.page.left, 280, 195, 280);
    
    // Page number
    doc.setFont('helvetica', FONTS.small.style);
    doc.setFontSize(FONTS.small.size);
    doc.setTextColor(COLORS.gray.r, COLORS.gray.g, COLORS.gray.b);
    doc.text(`Page ${i} of ${pageCount}`, 105, 285, { align: 'center' });
    
    // Footer text with report metadata
    doc.setFontSize(FONTS.tiny.size);
    doc.text(
      `PureTrack © ${dayjs().format('YYYY')} | Report ID: ${reportId}`,
      105,
      289,
      { align: 'center' }
    );
    
    // Generation timestamp
    doc.text(
      `Generated: ${dayjs().format('YYYY-MM-DD HH:mm:ss')}`,
      105,
      293,
      { align: 'center' }
    );
  }

  return doc;
};

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Determine overall water quality status based on summary metrics
 */
function getOverallStatus(summary: any): { status: string; color: [number, number, number] } {
  // Check if summary exists and has numeric values (use !== undefined to handle 0 values)
  if (!summary || 
      (summary.averageTurbidity === undefined && 
       summary.averageTDS === undefined && 
       summary.averagePH === undefined)) {
    return { status: 'NO DATA', color: [128, 128, 128] };
  }

  // If values are all 0, that's also no data
  if (summary.averageTurbidity === 0 && 
      summary.averageTDS === 0 && 
      summary.averagePH === 0 &&
      summary.totalReadings === 0) {
    return { status: 'NO DATA', color: [128, 128, 128] };
  }

  const turbidityOk = (summary.averageTurbidity || 0) <= 5;
  const tdsOk = (summary.averageTDS || 0) <= 500;
  const phOk = (summary.averagePH || 0) >= 6.5 && (summary.averagePH || 0) <= 8.5;

  const okCount = [turbidityOk, tdsOk, phOk].filter(Boolean).length;

  if (okCount === 3) {
    return { status: 'EXCELLENT', color: [82, 196, 26] }; // Green
  } else if (okCount === 2) {
    return { status: 'GOOD', color: [82, 196, 26] }; // Green
  } else if (okCount === 1) {
    return { status: 'FAIR - ATTENTION NEEDED', color: [250, 173, 20] }; // Orange
  } else {
    return { status: 'POOR - IMMEDIATE ACTION REQUIRED', color: [255, 77, 79] }; // Red
  }
}

/**
 * Generate recommendations based on report data
 */
function generateRecommendations(reportData: any): string[] {
  const recommendations: string[] = [];
  
  if (!reportData.devices || reportData.devices.length === 0) {
    return ['No devices found. Please check device configuration and connectivity.'];
  }

  const summary = reportData.summary;
  
  // Check for high turbidity
  if (summary?.averageTurbidity && summary.averageTurbidity > 5) {
    recommendations.push(
      `High turbidity detected (${summary.averageTurbidity.toFixed(2)} NTU). ` +
      'Investigate potential contamination sources and consider filtration system maintenance.'
    );
  }

  // Check for high TDS
  if (summary?.averageTDS && summary.averageTDS > 500) {
    recommendations.push(
      `Elevated TDS levels detected (${summary.averageTDS.toFixed(2)} ppm). ` +
      'Consider water treatment to reduce dissolved solids. Schedule pipe system inspection.'
    );
  }

  // Check for pH issues
  if (summary?.averagePH) {
    if (summary.averagePH < 6.5) {
      recommendations.push(
        `Low pH detected (${summary.averagePH.toFixed(2)}). Water is acidic. ` +
        'Install pH adjustment system. Check for corrosion in pipes.'
      );
    } else if (summary.averagePH > 8.5) {
      recommendations.push(
        `High pH detected (${summary.averagePH.toFixed(2)}). Water is alkaline. ` +
        'Install pH adjustment system. Test for mineral buildup.'
      );
    }
  }

  // Check for devices with no data
  const devicesWithNoData = reportData.devices.filter((d: any) => 
    !d.metrics || d.metrics.totalReadings === 0
  );
  if (devicesWithNoData.length > 0) {
    recommendations.push(
      `${devicesWithNoData.length} device(s) reported no data during this period. ` +
      'Check device connectivity, power supply, and sensor calibration.'
    );
  }

  // General maintenance
  if (recommendations.length === 0) {
    recommendations.push(
      'All parameters are within safe ranges. Continue regular monitoring and maintenance schedule.',
      'Perform sensor calibration as per manufacturer guidelines (typically every 3-6 months).',
      'Review historical trends to identify any gradual changes in water quality.'
    );
  } else {
    recommendations.push(
      'Schedule immediate inspection of flagged devices and water quality parameters.',
      'Increase monitoring frequency until issues are resolved.',
      'Document all corrective actions taken and verify effectiveness.'
    );
  }

  return recommendations;
}

/**
 * Calculate overall compliance metrics from summary data
 */
function calculateComplianceMetrics(summary: any): { rate: number; compliantCount: number; totalCount: number } {
  if (!summary || summary.totalReadings === 0) {
    return { rate: 0, compliantCount: 0, totalCount: 3 };
  }

  let compliantCount = 0;
  const totalCount = 3; // Turbidity, TDS, pH

  // Check each parameter against WHO guidelines
  if ((summary.averageTurbidity || 0) <= 5) compliantCount++;
  if ((summary.averageTDS || 0) <= 500) compliantCount++;
  if ((summary.averagePH || 0) >= 6.5 && (summary.averagePH || 0) <= 8.5) compliantCount++;

  const rate = Math.round((compliantCount / totalCount) * 100);

  return { rate, compliantCount, totalCount };
}

/**
 * Calculate compliance details for a specific device
 */
function calculateDeviceCompliance(metrics: any): {
  turbidity: { value: string; standard: string; status: string; percentage: string };
  tds: { value: string; standard: string; status: string; percentage: string };
  ph: { value: string; standard: string; status: string; percentage: string };
} {
  const turbidityValue = metrics.avgTurbidity || 0;
  const tdsValue = metrics.avgTDS || 0;
  const phValue = metrics.avgPH || 0;

  // Calculate compliance percentages (100% if compliant, otherwise calculate deviation)
  const turbidityCompliance = turbidityValue <= 5 ? 100 : Math.max(0, 100 - ((turbidityValue - 5) / 5) * 100);
  const tdsCompliance = tdsValue <= 500 ? 100 : Math.max(0, 100 - ((tdsValue - 500) / 500) * 100);
  const phCompliance = (phValue >= 6.5 && phValue <= 8.5) ? 100 : 
    Math.max(0, 100 - (Math.abs(phValue - 7.0) / 1.5) * 100);

  return {
    turbidity: {
      value: `${turbidityValue.toFixed(2)} NTU`,
      standard: '< 5 NTU',
      status: turbidityValue <= 5 ? 'Compliant' : 'Non-Compliant',
      percentage: `${turbidityCompliance.toFixed(1)}%`
    },
    tds: {
      value: `${tdsValue.toFixed(2)} ppm`,
      standard: '< 500 ppm',
      status: tdsValue <= 500 ? 'Compliant' : 'Non-Compliant',
      percentage: `${tdsCompliance.toFixed(1)}%`
    },
    ph: {
      value: phValue.toFixed(2),
      standard: '6.5 - 8.5',
      status: (phValue >= 6.5 && phValue <= 8.5) ? 'Compliant' : 'Non-Compliant',
      percentage: `${phCompliance.toFixed(1)}%`
    }
  };
}
