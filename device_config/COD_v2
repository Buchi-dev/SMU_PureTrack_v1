/*
 * Water Quality Monitoring System - 24/7 ULTRA-LEAN VERSION
 * Arduino UNO R4 WiFi - 30 Minute Data Transmission
 * Daily restart at 12:00 AM Philippine Time (16:00 UTC)
 * SSL/TLS ENABLED for HiveMQ Cloud (Port 8883)
 * 
 * Firmware: v6.6.0 - Production SSL
 */

#include <WiFiS3.h>
#include <WiFiSSLClient.h>
#include <PubSubClient.h>
#include <ArduinoJson.h>
#include <WiFiUdp.h>
#include <NTPClient.h>

// ===========================
// CONFIGURATION
// ===========================

// WiFi Credentials
#define WIFI_SSID "Yuzon Only"
#define WIFI_PASSWORD "Pldtadmin@2024"

// MQTT Broker Configuration - HiveMQ Cloud (SSL/TLS)
#define MQTT_BROKER "0331c5286d084675b9198021329c7573.s1.eu.hivemq.cloud"
#define MQTT_PORT 8883  // SSL/TLS port
#define MQTT_CLIENT_ID "arduino_uno_r4_002"
#define MQTT_USERNAME "Admin"
#define MQTT_PASSWORD "Admin123"

// Device Configuration
#define DEVICE_ID "arduino_uno_r4_002"
#define DEVICE_NAME "Water Quality Monitor R4"
#define DEVICE_TYPE "Arduino UNO R4 WiFi"
#define FIRMWARE_VERSION "6.6.0"

// Sensor Pin Configuration
#define TDS_PIN A0
#define PH_PIN A1
#define TURBIDITY_PIN A2

// Timing Configuration
#define SENSOR_READ_INTERVAL 60000      // 1 minute
#define DATA_SEND_INTERVAL 1800000      // 30 minutes
#define REGISTRATION_INTERVAL 60000     // 1 minute
#define MQTT_RECONNECT_INTERVAL 30000   // 30 seconds
#define STATUS_UPDATE_INTERVAL 1800000  // 30 minutes
#define WATCHDOG_INTERVAL 300000        // 5 minutes
#define NTP_UPDATE_INTERVAL 3600000     // 1 hour

// Time Settings - Philippine Time (UTC+8)
#define RESTART_HOUR_UTC 16             // 16:00 UTC = 12:00 AM PH Time
#define RESTART_MINUTE 0
#define TIMEZONE_OFFSET_SECONDS 28800   // +8 hours
#define MAX_UPTIME_HOURS 25

// 24/7 Operation Settings
#define MAX_MQTT_FAILURES 10            // Increased for SSL timeouts
#define MAX_WIFI_FAILURES 3

// ===========================
// CALIBRATION DATA
// ===========================

const int CALIB_COUNT = 4;
const int calibADC[CALIB_COUNT] = {105, 116, 224, 250};
const float calibPPM[CALIB_COUNT] = {236.0, 278.0, 1220.0, 1506.0};

const int PH_CALIB_COUNT = 3;
const int phCalibADC[PH_CALIB_COUNT] = {482, 503, 532};
const float phCalibPH[PH_CALIB_COUNT] = {9.81, 6.81, 4.16};

const float TDS_CALIBRATION_FACTOR = 0.589;
const float TDS_OFFSET = 0.0;

// ===========================
// SMA SMOOTHING BUFFERS
// ===========================

const int SMA_SIZE = 5;
int smaBuffer[SMA_SIZE];
int smaIndex = 0;
long smaSum = 0;
int smaCount = 0;

const int TURB_SMA_SIZE = 3;
int turbBuffer[TURB_SMA_SIZE];
int turbIndex = 0;
long turbSum = 0;
int turbCount = 0;

const int PH_SMA_SIZE = 3;
int phBuffer[PH_SMA_SIZE];
int phIndex = 0;
long phSum = 0;
int phCount = 0;

float fitSlope = 0.0;
float fitIntercept = 0.0;

// ===========================
// GLOBAL OBJECTS - SSL ENABLED
// ===========================
WiFiSSLClient wifiSSLClient;  // SSL client for encrypted connection
PubSubClient mqttClient(wifiSSLClient);
WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP, "pool.ntp.org", 0, NTP_UPDATE_INTERVAL);

// ===========================
// GLOBAL VARIABLES
// ===========================
unsigned long lastSensorRead = 0;
unsigned long lastDataSend = 0;
unsigned long lastRegistrationAttempt = 0;
unsigned long lastMqttReconnect = 0;
unsigned long lastStatusUpdate = 0;
unsigned long lastWatchdog = 0;
unsigned long lastNtpUpdate = 0;
unsigned long bootTime = 0;

bool isApproved = false;
bool mqttConnected = false;
bool timeInitialized = false;
bool restartScheduled = false;

float turbidity = 0.0;
float tds = 0.0;
float ph = 0.0;

int consecutiveMqttFailures = 0;
int consecutiveWifiFailures = 0;

unsigned long transmissionCount = 0;

// MQTT Topics
String topicData = "devices/" + String(DEVICE_ID) + "/data";
String topicStatus = "devices/" + String(DEVICE_ID) + "/status";
String topicRegister = "devices/" + String(DEVICE_ID) + "/register";
String topicCommands = "devices/" + String(DEVICE_ID) + "/commands";

// ===========================
// SETUP FUNCTION
// ===========================
void setup() {
  Serial.begin(115200);
  delay(2000);
  
  bootTime = millis();

  Serial.println("\n=== Arduino R4 - SSL/TLS Enabled ===");
  Serial.println("Firmware: v6.6.0");
  Serial.print("Boot: ");
  Serial.println(bootTime);
  Serial.println("MQTT: SSL/TLS (Port 8883)");
  Serial.println("Restart: 12:00 AM Philippine Time");
  
  // Initialize sensor pins
  pinMode(TDS_PIN, INPUT);
  pinMode(PH_PIN, INPUT);
  pinMode(TURBIDITY_PIN, INPUT);

  // Initialize buffers
  memset(smaBuffer, 0, sizeof(smaBuffer));
  memset(phBuffer, 0, sizeof(phBuffer));
  memset(turbBuffer, 0, sizeof(turbBuffer));

  computeCalibrationParams();
  printCalibrationInfo();

  // MQTT Configuration - SSL optimized
  mqttClient.setServer(MQTT_BROKER, MQTT_PORT);
  mqttClient.setCallback(mqttCallback);
  mqttClient.setKeepAlive(90);           // Increased for SSL
  mqttClient.setSocketTimeout(60);       // Increased for SSL handshake
  mqttClient.setBufferSize(512);

  Serial.println("\n=== Connecting... ===");
  
  connectWiFi();
  
  if (WiFi.status() == WL_CONNECTED && WiFi.localIP() != IPAddress(0, 0, 0, 0)) {
    
    // Initialize NTP
    timeClient.begin();
    delay(1000);
    
    // Try NTP sync multiple times
    Serial.print("NTP sync");
    for (int i = 0; i < 5; i++) {
      Serial.print(".");
      if (timeClient.update()) {
        timeInitialized = true;
        Serial.println(" OK");
        printCurrentTime();
        break;
      }
      delay(1000);
    }
    
    if (!timeInitialized) {
      Serial.println(" Failed (will retry)");
    }
    
    // Wait before SSL connection
    delay(2000);
    
    // Connect to MQTT with SSL
    connectMQTT();
    
    if (mqttConnected) {
      delay(3000);
      sendRegistration();
    }
  }

  Serial.println("\n=== System Ready ===\n");
}

// ===========================
// MAIN LOOP
// ===========================
void loop() {
  unsigned long currentMillis = millis();

  // Safety fallback
  if ((currentMillis - bootTime) / 3600000UL >= MAX_UPTIME_HOURS) {
    Serial.println("Max uptime - safety restart");
    delay(2000);
    NVIC_SystemReset();
  }

  // Check for midnight restart
  if (timeInitialized) {
    checkMidnightRestart();
  }

  // WiFi management
  if (WiFi.status() != WL_CONNECTED) {
    handleWiFiDisconnection();
    delay(5000);
    return;
  } else {
    consecutiveWifiFailures = 0;
  }

  // Update NTP time periodically
  if (timeInitialized && currentMillis - lastNtpUpdate >= NTP_UPDATE_INTERVAL) {
    lastNtpUpdate = currentMillis;
    timeClient.update();
  }

  // Initialize time if not yet done
  if (!timeInitialized && WiFi.status() == WL_CONNECTED) {
    if (timeClient.update()) {
      timeInitialized = true;
      Serial.println("NTP time synchronized");
      printCurrentTime();
    }
  }

  // MQTT management
  if (!mqttClient.connected()) {
    mqttConnected = false;
    
    bool needMqtt = !isApproved || 
                    (currentMillis - lastDataSend >= DATA_SEND_INTERVAL);
    
    if (needMqtt && currentMillis - lastMqttReconnect >= MQTT_RECONNECT_INTERVAL) {
      lastMqttReconnect = currentMillis;
      connectMQTT();
    }
  } else {
    mqttClient.loop();
    consecutiveMqttFailures = 0;
  }

  // Watchdog heartbeat
  if (currentMillis - lastWatchdog >= WATCHDOG_INTERVAL) {
    lastWatchdog = currentMillis;
    printWatchdog();
  }

  // Registration mode
  if (!isApproved) {
    if (currentMillis - lastRegistrationAttempt >= REGISTRATION_INTERVAL) {
      lastRegistrationAttempt = currentMillis;
      if (mqttConnected) {
        sendRegistration();
      }
    }
  } 
  // Active monitoring mode
  else {
    // Read sensors every 1 minute
    if (currentMillis - lastSensorRead >= SENSOR_READ_INTERVAL) {
      lastSensorRead = currentMillis;
      readSensors();
      
      unsigned long timeSinceLastSend = currentMillis - lastDataSend;
      unsigned long timeUntilNextSend = DATA_SEND_INTERVAL - timeSinceLastSend;
      Serial.print("Next TX: ");
      Serial.print(timeUntilNextSend / 60000);
      Serial.println(" min");
    }

    // Send data every 30 minutes
    if (currentMillis - lastDataSend >= DATA_SEND_INTERVAL) {
      lastDataSend = currentMillis;
      
      Serial.println("\n=== 30-MIN TX ===");
      
      if (!mqttConnected) {
        connectMQTT();
        delay(3000);  // Wait for SSL handshake
      }
      
      if (mqttConnected) {
        publishSensorData();
        sendStatusUpdate();
        transmissionCount++;
        
        Serial.print("TX Count: ");
        Serial.println(transmissionCount);
      } else {
        Serial.println("MQTT unavailable");
      }
      
      Serial.println("=== COMPLETE ===\n");
    }
  }

  delay(100);
}

// ===========================
// TIME MANAGEMENT FUNCTIONS
// ===========================

void checkMidnightRestart() {
  if (restartScheduled) return;
  
  timeClient.update();
  
  int currentHourUTC = timeClient.getHours();
  int currentMinuteUTC = timeClient.getMinutes();
  
  if (currentHourUTC == RESTART_HOUR_UTC && currentMinuteUTC == RESTART_MINUTE) {
    
    if (!restartScheduled) {
      restartScheduled = true;
      
      Serial.println("\n=========================================");
      Serial.println("MIDNIGHT RESTART (Philippine Time)");
      Serial.print("UTC Time: ");
      Serial.println(timeClient.getFormattedTime());
      Serial.print("PH Time: ");
      printPhilippineTime();
      Serial.print("Uptime: ");
      Serial.print((millis() - bootTime) / 3600000);
      Serial.println(" hours");
      Serial.println("Restarting in 5 seconds...");
      Serial.println("=========================================\n");
      
      if (mqttConnected) {
        sendShutdownStatus();
      }
      
      delay(5000);
      NVIC_SystemReset();
    }
  } else {
    if (currentMinuteUTC > 1) {
      restartScheduled = false;
    }
  }
}

void printCurrentTime() {
  Serial.print("UTC Time: ");
  Serial.println(timeClient.getFormattedTime());
  
  Serial.print("PH Time:  ");
  printPhilippineTime();
  
  int currentHourUTC = timeClient.getHours();
  int hoursUntilRestart;
  
  if (currentHourUTC < RESTART_HOUR_UTC) {
    hoursUntilRestart = RESTART_HOUR_UTC - currentHourUTC;
  } else {
    hoursUntilRestart = 24 - currentHourUTC + RESTART_HOUR_UTC;
  }
  
  int minutesUntilRestart = (60 - timeClient.getMinutes()) % 60;
  
  Serial.print("Next restart: ");
  Serial.print(hoursUntilRestart);
  Serial.print("h ");
  Serial.print(minutesUntilRestart);
  Serial.println("m");
}

void printPhilippineTime() {
  unsigned long epochTime = timeClient.getEpochTime();
  unsigned long phTime = epochTime + TIMEZONE_OFFSET_SECONDS;
  
  int hours = (phTime % 86400L) / 3600;
  int minutes = (phTime % 3600) / 60;
  int seconds = phTime % 60;
  
  char timeStr[9];
  sprintf(timeStr, "%02d:%02d:%02d", hours, minutes, seconds);
  Serial.println(timeStr);
}

String getPhilippineTimeString() {
  unsigned long epochTime = timeClient.getEpochTime();
  unsigned long phTime = epochTime + TIMEZONE_OFFSET_SECONDS;
  
  int hours = (phTime % 86400L) / 3600;
  int minutes = (phTime % 3600) / 60;
  int seconds = phTime % 60;
  
  char timeStr[9];
  sprintf(timeStr, "%02d:%02d:%02d", hours, minutes, seconds);
  return String(timeStr);
}

// ===========================
// WIFI FUNCTIONS
// ===========================

void connectWiFi() {
  Serial.print("WiFi: ");
  Serial.println(WIFI_SSID);
  
  WiFi.disconnect();
  delay(500);
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);

  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 30) {
    Serial.print(".");
    delay(500);
    attempts++;
  }

  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("\nWiFi FAILED");
    consecutiveWifiFailures++;
    
    if (consecutiveWifiFailures >= MAX_WIFI_FAILURES) {
      Serial.println("Max WiFi failures - rebooting");
      delay(3000);
      NVIC_SystemReset();
    }
    return;
  }

  Serial.println("\nWiFi OK");
  
  // Wait for valid IP address
  attempts = 0;
  while (WiFi.localIP() == IPAddress(0, 0, 0, 0) && attempts < 20) {
    Serial.print("Waiting for IP");
    delay(500);
    attempts++;
  }
  
  if (WiFi.localIP() == IPAddress(0, 0, 0, 0)) {
    Serial.println("\nNo IP assigned - reconnecting");
    consecutiveWifiFailures++;
    delay(2000);
    connectWiFi();
    return;
  }
  
  Serial.print("IP: ");
  Serial.println(WiFi.localIP());
  Serial.print("RSSI: ");
  Serial.println(WiFi.RSSI());
  
  consecutiveWifiFailures = 0;
}

void handleWiFiDisconnection() {
  Serial.println("WiFi lost - reconnecting");
  consecutiveWifiFailures++;
  mqttConnected = false;
  connectWiFi();
  
  if (WiFi.status() == WL_CONNECTED && WiFi.localIP() != IPAddress(0, 0, 0, 0)) {
    delay(1000);
    
    if (!timeInitialized) {
      timeClient.update();
      timeInitialized = true;
    }
  }
}

// ===========================
// MQTT FUNCTIONS - SSL OPTIMIZED
// ===========================

void connectMQTT() {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("MQTT: No WiFi");
    return;
  }

  if (WiFi.localIP() == IPAddress(0, 0, 0, 0)) {
    Serial.println("MQTT: No IP address");
    return;
  }

  if (mqttClient.connected()) {
    mqttConnected = true;
    return;
  }

  Serial.println("\n--- MQTT SSL Connection ---");
  Serial.print("Broker: ");
  Serial.println(MQTT_BROKER);
  Serial.print("Port: ");
  Serial.print(MQTT_PORT);
  Serial.println(" (SSL/TLS)");
  Serial.println("Establishing SSL handshake...");

  // SSL connection takes longer - be patient
  bool connected = mqttClient.connect(
    MQTT_CLIENT_ID,
    MQTT_USERNAME,
    MQTT_PASSWORD,
    topicStatus.c_str(),
    0,
    true,
    "{\"status\":\"offline\"}"
  );

  if (connected) {
    Serial.println("✓ MQTT SSL Connected!");
    mqttConnected = true;
    consecutiveMqttFailures = 0;

    if (mqttClient.subscribe(topicCommands.c_str(), 0)) {
      Serial.print("✓ Subscribed: ");
      Serial.println(topicCommands);
    }
    
  } else {
    Serial.print("✗ MQTT SSL Failed: ");
    Serial.println(mqttClient.state());
    printMqttError(mqttClient.state());
    
    mqttConnected = false;
    consecutiveMqttFailures++;
    
    if (consecutiveMqttFailures >= MAX_MQTT_FAILURES) {
      Serial.println("Max MQTT failures - resetting connection");
      mqttClient.disconnect();
      delay(5000);
      consecutiveMqttFailures = 0;
    }
  }
  
  Serial.println("--- End MQTT Connection ---\n");
}

void printMqttError(int state) {
  switch (state) {
    case -4: Serial.println("  SSL_CONNECTION_TIMEOUT - Check firewall/SSL cert"); break;
    case -3: Serial.println("  CONNECTION_LOST"); break;
    case -2: Serial.println("  CONNECT_FAILED - Check broker address"); break;
    case -1: Serial.println("  DISCONNECTED"); break;
    case 1: Serial.println("  BAD_PROTOCOL"); break;
    case 2: Serial.println("  BAD_CLIENT_ID"); break;
    case 3: Serial.println("  UNAVAILABLE - Broker down"); break;
    case 4: Serial.println("  BAD_CREDENTIALS - Check username/password"); break;
    case 5: Serial.println("  UNAUTHORIZED"); break;
    default: Serial.println("  UNKNOWN"); break;
  }
}

void mqttCallback(char* topic, byte* payload, unsigned int length) {
  Serial.print("MQTT RX: ");
  
  char message[length + 1];
  memcpy(message, payload, length);
  message[length] = '\0';
  Serial.println(message);

  StaticJsonDocument<256> doc;
  DeserializationError error = deserializeJson(doc, message);

  if (error) {
    Serial.println("JSON error");
    return;
  }

  const char* command = doc["command"];
  
  if (command == nullptr) return;

  if (strcmp(command, "go") == 0) {
    Serial.println("CMD: GO");
    isApproved = true;
    lastDataSend = millis() - DATA_SEND_INTERVAL;
    
  } else if (strcmp(command, "deregister") == 0) {
    Serial.println("CMD: DEREGISTER");
    isApproved = false;
    
  } else if (strcmp(command, "restart") == 0) {
    Serial.println("CMD: RESTART");
    delay(1000);
    NVIC_SystemReset();
    
  } else if (strcmp(command, "send_now") == 0) {
    Serial.println("CMD: SEND NOW");
    lastDataSend = millis() - DATA_SEND_INTERVAL;
    
  } else if (strcmp(command, "sync_time") == 0) {
    Serial.println("CMD: SYNC TIME");
    timeClient.forceUpdate();
    printCurrentTime();
    
  } else {
    Serial.print("CMD: Unknown - ");
    Serial.println(command);
  }
}

// ===========================
// MQTT PUBLISH FUNCTIONS
// ===========================

void publishSensorData() {
  if (!mqttClient.connected()) {
    Serial.println("MQTT not connected");
    return;
  }

  StaticJsonDocument<256> doc;
  doc["deviceId"] = DEVICE_ID;
  doc["timestamp"] = timeInitialized ? timeClient.getEpochTime() : (millis() / 1000);
  doc["tds"] = round(tds * 10) / 10.0;
  doc["pH"] = round(ph * 100) / 100.0;
  doc["turbidity"] = round(turbidity * 10) / 10.0;
  doc["messageType"] = "sensor_data";
  doc["interval"] = "30min";
  doc["transmissionNumber"] = transmissionCount;

  String payload;
  serializeJson(doc, payload);

  Serial.print("Publishing (");
  Serial.print(payload.length());
  Serial.println(" bytes):");
  Serial.println(payload);

  if (mqttClient.publish(topicData.c_str(), payload.c_str(), false)) {
    Serial.println("✓ Published!");
  } else {
    Serial.println("✗ Publish failed!");
    Serial.print("State: ");
    Serial.println(mqttClient.state());
    consecutiveMqttFailures++;
  }
}

void sendRegistration() {
  if (!mqttClient.connected()) {
    Serial.println("MQTT not connected - cannot register");
    return;
  }

  if (WiFi.localIP() == IPAddress(0, 0, 0, 0)) {
    Serial.println("No IP - cannot register");
    return;
  }

  Serial.println("\n--- Device Registration ---");

  StaticJsonDocument<512> doc;
  doc["deviceId"] = DEVICE_ID;
  doc["name"] = DEVICE_NAME;
  doc["type"] = DEVICE_TYPE;
  doc["firmwareVersion"] = FIRMWARE_VERSION;
  doc["timestamp"] = timeInitialized ? timeClient.getEpochTime() : (millis() / 1000);
  doc["messageType"] = "registration";
  doc["uptime"] = (millis() - bootTime) / 1000;
  doc["dataInterval"] = 1800;
  doc["restartSchedule"] = "daily_midnight_ph";
  doc["timezone"] = "Asia/Manila";
  doc["connectionType"] = "SSL/TLS";

  uint8_t macRaw[6];
  WiFi.macAddress(macRaw);
  char mac[18];
  snprintf(mac, sizeof(mac), "%02X:%02X:%02X:%02X:%02X:%02X",
           macRaw[0], macRaw[1], macRaw[2], macRaw[3], macRaw[4], macRaw[5]);
  doc["macAddress"] = mac;
  doc["ipAddress"] = WiFi.localIP().toString();
  doc["rssi"] = WiFi.RSSI();
  
  if (timeInitialized) {
    doc["utcTime"] = timeClient.getFormattedTime();
    doc["phTime"] = getPhilippineTimeString();
  }

  JsonArray sensors = doc.createNestedArray("sensors");
  sensors.add("pH");
  sensors.add("turbidity");
  sensors.add("tds");

  String payload;
  serializeJson(doc, payload);

  Serial.print("Size: ");
  Serial.print(payload.length());
  Serial.println(" bytes");
  Serial.println(payload);

  bool published = mqttClient.publish(topicRegister.c_str(), payload.c_str(), false);

  if (published) {
    Serial.println("✓ Registration sent!");
  } else {
    Serial.println("✗ Registration failed!");
    Serial.print("MQTT state: ");
    Serial.println(mqttClient.state());
    printMqttError(mqttClient.state());
  }
  
  Serial.println("--- End Registration ---\n");
}

void sendStatusUpdate() {
  if (!mqttClient.connected()) {
    return;
  }

  StaticJsonDocument<256> doc;
  doc["deviceId"] = DEVICE_ID;
  doc["timestamp"] = timeInitialized ? timeClient.getEpochTime() : (millis() / 1000);
  doc["status"] = "online";
  doc["uptime"] = (millis() - bootTime) / 1000;
  doc["wifiRSSI"] = WiFi.RSSI();
  doc["firmwareVersion"] = FIRMWARE_VERSION;
  doc["messageType"] = "device_status";
  doc["isApproved"] = isApproved;
  doc["transmissionCount"] = transmissionCount;
  
  if (timeInitialized) {
    doc["utcTime"] = timeClient.getFormattedTime();
    doc["phTime"] = getPhilippineTimeString();
  }

  String payload;
  serializeJson(doc, payload);

  mqttClient.publish(topicStatus.c_str(), payload.c_str(), false);
}

void sendShutdownStatus() {
  StaticJsonDocument<256> doc;
  doc["deviceId"] = DEVICE_ID;
  doc["timestamp"] = timeInitialized ? timeClient.getEpochTime() : (millis() / 1000);
  doc["status"] = "restarting";
  doc["reason"] = "scheduled_midnight_ph_time";
  doc["uptime"] = (millis() - bootTime) / 1000;
  doc["messageType"] = "device_status";
  
  String payload;
  serializeJson(doc, payload);

  mqttClient.publish(topicStatus.c_str(), payload.c_str(), true);
  delay(500);
}

// ===========================
// CALIBRATION FUNCTIONS
// ===========================

void computeCalibrationParams() {
  float meanX = 0.0, meanY = 0.0;
  for (int i = 0; i < CALIB_COUNT; i++) {
    meanX += calibADC[i];
    meanY += calibPPM[i];
  }
  meanX /= CALIB_COUNT;
  meanY /= CALIB_COUNT;
  
  float num = 0.0, den = 0.0;
  for (int i = 0; i < CALIB_COUNT; i++) {
    float dx = calibADC[i] - meanX;
    float dy = calibPPM[i] - meanY;
    num += dx * dy;
    den += dx * dx;
  }
  
  if (den != 0.0) {
    fitSlope = num / den;
    fitIntercept = meanY - fitSlope * meanX;
  }
}

void printCalibrationInfo() {
  Serial.println("=== CALIBRATION ===");
  Serial.print("Slope: ");
  Serial.println(fitSlope, 3);
  Serial.print("Intercept: ");
  Serial.println(fitIntercept, 2);
  Serial.println("===================");
}

float adcToPPM(int adc) {
  for (int i = 0; i < CALIB_COUNT - 1; i++) {
    if (adc >= calibADC[i] && adc <= calibADC[i + 1]) {
      float slope = (calibPPM[i + 1] - calibPPM[i]) / (float)(calibADC[i + 1] - calibADC[i]);
      return calibPPM[i] + slope * (adc - calibADC[i]);
    }
  }
  return fitSlope * adc + fitIntercept;
}

float adcToPH(int adc) {
  for (int i = 0; i < PH_CALIB_COUNT - 1; i++) {
    if (adc >= phCalibADC[i] && adc <= phCalibADC[i + 1]) {
      float slope = (phCalibPH[i + 1] - phCalibPH[i]) / (float)(phCalibADC[i + 1] - phCalibADC[i]);
      return phCalibPH[i] + slope * (adc - phCalibADC[i]);
    }
  }
  return 7.0;
}

float calculateTurbidityNTU(int adcValue) {
  float ntu = -0.1613 * adcValue + 27.74;
  return (ntu < 0) ? 0 : ntu;
}

// ===========================
// SENSOR READING
// ===========================

void readSensors() {
  int rawTDS = analogRead(TDS_PIN);
  int rawPH = analogRead(PH_PIN);
  int rawTurb = analogRead(TURBIDITY_PIN);

  smaSum -= smaBuffer[smaIndex];
  smaBuffer[smaIndex] = rawTDS;
  smaSum += rawTDS;
  smaIndex = (smaIndex + 1) % SMA_SIZE;
  if (smaCount < SMA_SIZE) smaCount++;

  phSum -= phBuffer[phIndex];
  phBuffer[phIndex] = rawPH;
  phSum += rawPH;
  phIndex = (phIndex + 1) % PH_SMA_SIZE;
  if (phCount < PH_SMA_SIZE) phCount++;

  turbSum -= turbBuffer[turbIndex];
  turbBuffer[turbIndex] = rawTurb;
  turbSum += rawTurb;
  turbIndex = (turbIndex + 1) % TURB_SMA_SIZE;
  if (turbCount < TURB_SMA_SIZE) turbCount++;

  int avgTDS = smaSum / max(1, smaCount);
  int avgPH = phSum / max(1, phCount);
  int avgTurb = turbSum / max(1, turbCount);

  float ppm = adcToPPM(avgTDS);
  tds = (ppm * TDS_CALIBRATION_FACTOR) + TDS_OFFSET;
  
  ph = adcToPH(avgPH);
  if (ph < 0.0) ph = 0.0;
  if (ph > 14.0) ph = 14.0;

  int turb10bit = avgTurb / 16;
  turbidity = calculateTurbidityNTU(turb10bit);

  Serial.print("[");
  if (timeInitialized) {
    Serial.print(getPhilippineTimeString());
    Serial.print(" PH");
  } else {
    Serial.print((millis() - bootTime) / 1000);
    Serial.print("s");
  }
  Serial.print("] TDS:");
  Serial.print(tds, 1);
  Serial.print(" pH:");
  Serial.print(ph, 2);
  Serial.print(" Turb:");
  Serial.println(turbidity, 1);
}

// ===========================
// WATCHDOG
// ===========================

void printWatchdog() {
  Serial.println("\n=== WATCHDOG ===");
  Serial.print("Uptime: ");
  Serial.print((millis() - bootTime) / 3600);
  Serial.println("h");
  
  Serial.print("IP: ");
  Serial.println(WiFi.localIP());
  
  if (timeInitialized) {
    Serial.print("UTC:  ");
    Serial.println(timeClient.getFormattedTime());
    Serial.print("PH:   ");
    Serial.println(getPhilippineTimeString());
    
    int currentHourUTC = timeClient.getHours();
    int hoursUntilRestart;
    
    if (currentHourUTC < RESTART_HOUR_UTC) {
      hoursUntilRestart = RESTART_HOUR_UTC - currentHourUTC;
    } else {
      hoursUntilRestart = 24 - currentHourUTC + RESTART_HOUR_UTC;
    }
    
    Serial.print("Restart in: ");
    Serial.print(hoursUntilRestart);
    Serial.println("h");
  } else {
    Serial.println("Time: Not synced");
  }
  
  Serial.print("WiFi: ");
  Serial.println(WiFi.status() == WL_CONNECTED ? "OK" : "DOWN");
  Serial.print("MQTT SSL: ");
  Serial.println(mqttConnected ? "OK" : "DOWN");
  Serial.print("TX: ");
  Serial.println(transmissionCount);
  Serial.println("================\n");
}
